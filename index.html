<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Scene Editor - CSG Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/mode/simple.min.js"></script>
    
    <style>
        /* Gruvbox Dark Theme for CodeMirror */
        .cm-s-gruvbox-dark.CodeMirror {
            background-color: #1d2021;
            color: #ebdbb2;
            height: 100%;
        }
        .cm-s-gruvbox-dark .CodeMirror-gutters {
            background-color: #1d2021;
            border-right: 1px solid #3c3836;
        }
        .cm-s-gruvbox-dark .CodeMirror-linenumber {
            color: #7c6f64;
        }
        .cm-s-gruvbox-dark .CodeMirror-cursor {
            border-left: 1px solid #ebdbb2;
        }
        .cm-s-gruvbox-dark span.cm-comment {
            color: #928374;
        }
        .cm-s-gruvbox-dark span.cm-keyword {
            color: #fb4934;
        }
        .cm-s-gruvbox-dark span.cm-variable {
            color: #83a598;
        }
        .cm-s-gruvbox-dark span.cm-type {
            color: #fabd2f;
        }
        .cm-s-gruvbox-dark span.cm-string {
            color: #b8bb26;
        }
        .cm-s-gruvbox-dark span.cm-number {
            color: #d3869b;
        }

        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            background: #3c3836;
            border-radius: 4px;
            height: 8px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #83a598;
            cursor: pointer;
            border: 2px solid #1d2021;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #8ec07c;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #83a598;
            cursor: pointer;
            border: 2px solid #1d2021;
        }

        /* Layout */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        #container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
        
        #editor-side {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50%;
            max-width: 800px;
            height: calc(100vh - 40px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        #editor-side.panel-hidden {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }
        #editor-main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #code-editor-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .CodeMirror {
            flex: 1;
            height: auto;
            width: 100%;
            max-width: 100%;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }
        
        #side-panel {
            width: 320px;
            min-width: 320px;
            max-width: 320px;
            flex: 0 0 320px;
            background: #1d2021;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            border-left: 1px solid #3c3836;
        }
        
        .csg-controls {
            background: #2d2d2d;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">
    <div id="container">
        
        <div id="canvas-container" class="relative bg-black flex items-center justify-center">
            <canvas id="canvas" class="block"></canvas>
            
            <div id="error-message" class="absolute bottom-4 left-4 right-4 bg-red-900/90 text-red-200 p-3 rounded text-xs font-mono hidden max-h-32 overflow-auto">
            </div>
            
            <div class="absolute top-4 left-4 bg-black/70 px-3 py-2 rounded text-sm font-mono">
                <span class="text-gray-400">FPS:</span> <span id="fps" class="text-green-400">0</span>
            </div>
            
            <button id="floating-toggle-btn" class="absolute top-4 right-4 bg-blue-700 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-lg transition hidden" style="z-index: 5;">
                üé® Show Editor
            </button>
        </div>
        
        <div id="editor-side" class="bg-gray-800">
            
            <div class="bg-[#1d2021] border-b border-gray-700 p-3 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-blue-400">
                        <path d="M12 2L2 7L12 12L22 7L12 2Z"/>
                        <path d="M2 17L12 22L22 17"/>
                        <path d="M2 12L12 17L22 12"/>
                    </svg>
                    <span class="font-bold text-gray-200">WebGPU Scene Editor - CSG</span>
                </div>
                
                <div class="flex items-center gap-3">
                    <button id="compile-btn" class="bg-green-700 hover:bg-green-600 text-white px-4 py-1 rounded text-sm font-semibold transition">
                        Compile
                    </button>
                    <button id="toggle-panel-btn" class="bg-blue-700 hover:bg-blue-600 text-white px-4 py-1 rounded text-sm font-semibold transition" title="Toggle Scene Panel">
                        ‚úñÔ∏è Close
                    </button>
                </div>
            </div>
            
            <div id="editor-main">
                
                <div id="code-editor-wrapper">
                    <textarea id="code-editor"></textarea>
                </div>
                
                <div id="side-panel" class="bg-[#1d2021] border-l border-gray-700 overflow-y-auto">
                    
                    <div class="p-4 border-b border-gray-700">
                        <h3 class="font-bold text-gray-200 mb-3 flex items-center gap-2">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"/>
                                <rect x="14" y="3" width="7" height="7"/>
                                <rect x="14" y="14" width="7" height="7"/>
                                <rect x="3" y="14" width="7" height="7"/>
                            </svg>
                            System Uniforms
                        </h3>
                        <div class="space-y-2 text-xs font-mono text-gray-400">
                            <div><span class="text-gray-500">Resolution:</span> <span id="u-resolution">0x0</span></div>
                            <div><span class="text-gray-500">Time:</span> <span id="u-time">0.00s</span></div>
                            <div><span class="text-gray-500">Frame:</span> <span id="u-frame">0</span></div>
                            <div><span class="text-gray-500">Mouse:</span> <span id="u-mouse">(0, 0)</span></div>
                        </div>
                    </div>
                    
                    <div class="p-4">
                        <h3 class="font-bold text-gray-200 mb-3 flex items-center gap-2">
                            üé® Scene Editor (CSG)
                        </h3>
                        
                        <!-- OBJECT MANAGER -->
                        <div class="mb-6 p-4 bg-gray-800 rounded-lg border border-gray-600">
                            <div class="text-sm font-semibold text-cyan-400 mb-3">üéõÔ∏è Object Manager</div>
                            
                            <div class="flex gap-2 mb-3">
                                <button id="add-sphere-btn" class="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm rounded font-semibold transition-colors">
                                    ‚ûï Sphere
                                </button>
                                <button id="remove-sphere-btn" class="flex-1 px-3 py-2 bg-red-900 hover:bg-red-800 text-white text-sm rounded transition-colors">
                                    ‚ûñ
                                </button>
                            </div>
                            
                            <div class="flex gap-2 mb-3">
                                <button id="add-box-btn" class="flex-1 px-3 py-2 bg-green-600 hover:bg-green-700 text-white text-sm rounded font-semibold transition-colors">
                                    ‚ûï Box
                                </button>
                                <button id="remove-box-btn" class="flex-1 px-3 py-2 bg-green-900 hover:bg-green-800 text-white text-sm rounded transition-colors">
                                    ‚ûñ
                                </button>
                            </div>
                            
                            <div class="flex gap-2">
                                <button id="add-torus-btn" class="flex-1 px-3 py-2 bg-cyan-600 hover:bg-cyan-700 text-white text-sm rounded font-semibold transition-colors">
                                    ‚ûï Torus
                                </button>
                                <button id="remove-torus-btn" class="flex-1 px-3 py-2 bg-cyan-900 hover:bg-cyan-800 text-white text-sm rounded transition-colors">
                                    ‚ûñ
                                </button>
                            </div>
                            
                            <div class="mt-3 p-2 bg-gray-900 rounded text-xs text-gray-400">
                                <div class="flex justify-between">
                                    <span>Spheres:</span>
                                    <span id="sphere-count" class="font-mono text-red-400">0</span>
                                </div>
                                <div class="flex justify-between mt-1">
                                    <span>Boxes:</span>
                                    <span id="box-count" class="font-mono text-green-400">0</span>
                                </div>
                                <div class="flex justify-between mt-1">
                                    <span>Tori:</span>
                                    <span id="torus-count" class="font-mono text-cyan-400">0</span>
                                </div>
                            </div>
                            
                            <div class="mt-3 p-2 bg-purple-900/30 rounded text-xs text-purple-300">
                                <div class="font-semibold mb-1">üí° CSG Modes:</div>
                                <div>‚Ä¢ Normal: Suit le smooth actif</div>
                                <div>‚Ä¢ Smooth: Fusionne (propage!)</div>
                                <div>‚Ä¢ Subtract: Creuse la sc√®ne</div>
                                <div>‚Ä¢ Intersect: Garde l'overlap</div>
                            </div>
                        </div>
                        
                        <!-- DYNAMIC PANELS CONTAINER -->
                        <div id="object-panels-container">
                            <!-- Panels will be generated dynamically -->
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================================
        // GLOBAL VARIABLES
        // ================================================
        let device, context, pipeline, bindGroup;
        let uniformBuffer, sceneBuffer;
        let canvas, editor;
        let sceneData;
        
        let startTime = performance.now();
        let lastFrameTime = startTime;
        let frameCount = 0;
        let lastFpsUpdate = startTime;
        
        let mouseX = 0, mouseY = 0, mouseDown = 0;
        
        // Camera controls
        let cameraYaw = 0.0;
        let cameraPitch = 0.5;
        let cameraDistance = 5.0;
        let cameraTargetX = 0.0;
        let cameraTargetY = 0.0;
        let cameraTargetZ = 0.0;
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Object counts
        let activeSpheres = 0;
        let activeBoxes = 0;
        let activeTori = 0;
        
        // Object picking
        let selectedObject = null; // { type: 'sphere', index: 0 }
        let isDraggingObject = false;
        let dragStartPos = null;
        
        // ================================================
        // WGSL SHADERS
        // ================================================
        
        const vertexShader = `
@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
    var pos = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(3.0, -1.0),
        vec2<f32>(-1.0, 3.0)
    );
    return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}
`;

        const uniformsStruct = `
struct Uniforms {
    resolution: vec2<f32>,
    time: f32,
    deltaTime: f32,
    mouse: vec4<f32>,
    frame: u32,
    _padding: u32,
    _padding2: u32,
    _padding3: u32,
    cameraYaw: f32,
    cameraPitch: f32,
    cameraDistance: f32,
    _cameraPadding: f32,
    cameraTargetX: f32,
    cameraTargetY: f32,
    cameraTargetZ: f32,
    _cameraPadding2: f32,
}
@group(0) @binding(0) var<uniform> uniforms: Uniforms;
`;

        const sceneStruct = `
struct Sphere {
    center: vec3<f32>,
    radius: f32,
    color: vec3<f32>,
    blend_mode: f32,
    blend_amount: f32,
    _padding1: f32,
    _padding2: f32,
    _padding3: f32,
}

struct Box {
    center: vec3<f32>,
    _padding1: f32,
    size: vec3<f32>,
    _padding2: f32,
    color: vec3<f32>,
    blend_mode: f32,
    blend_amount: f32,
    _padding3: f32,
    _padding4: f32,
    _padding5: f32,
}

struct Torus {
    center: vec3<f32>,
    _padding1: f32,
    radii: vec2<f32>,
    _padding2: vec2<f32>,
    color: vec3<f32>,
    blend_mode: f32,
    blend_amount: f32,
    _padding3: f32,
    _padding4: f32,
    _padding5: f32,
}

struct Scene {
    num_spheres: u32,
    num_boxes: u32,
    num_tori: u32,
    _padding: u32,
    spheres: array<Sphere, 10>,
    boxes: array<Box, 10>,
    tori: array<Torus, 10>,
}
@group(0) @binding(1) var<uniform> scene: Scene;
`;

        const mainShader = `
// ===== CONSTANTS =====
const MAX_DIST: f32 = 100.0;
const SURF_DIST: f32 = 0.001;
const MAX_STEPS: i32 = 256;

// ===== SDF PRIMITIVES =====
fn sd_sphere(p: vec3<f32>, r: f32) -> f32 {
    return length(p) - r;
}

fn sd_box(p: vec3<f32>, b: vec3<f32>) -> f32 {
    let q = abs(p) - b;
    return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);
}

fn sd_torus(p: vec3<f32>, t: vec2<f32>) -> f32 {
    let q = vec2<f32>(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

fn sd_plane(p: vec3<f32>, n: vec3<f32>, h: f32) -> f32 {
    return dot(p, n) + h;
}

// ===== CSG OPERATIONS =====
fn smin(a: f32, b: f32, k: f32) -> f32 {
    let h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

fn smax(a: f32, b: f32, k: f32) -> f32 {
    return -smin(-a, -b, k);
}

// CSG blend with color mixing
// Returns vec4(distance, color.rgb)
fn csg_blend(d1: f32, c1: vec3<f32>, d2: f32, c2: vec3<f32>, mode: f32, k: f32) -> vec4<f32> {
    let m = i32(mode + 0.5);
    
    if m == 0 {
        // Normal - simple min, keep closer color
        if d2 < d1 {
            return vec4<f32>(d2, c2);
        }
        return vec4<f32>(d1, c1);
    } else if m == 1 {
        // Smooth Union - blend colors based on distance
        let h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
        let d = mix(d2, d1, h) - k * h * (1.0 - h);
        let c = mix(c2, c1, h);
        return vec4<f32>(d, c);
    } else if m == 2 {
        // Subtract (d1 - d2) - keep d1's color
        let d = smax(d1, -d2, k);
        return vec4<f32>(d, c1);
    } else if m == 3 {
        // Intersect - keep closer color
        let d = max(d1, d2);
        if d1 > d2 {
            return vec4<f32>(d, c1);
        }
        return vec4<f32>(d, c2);
    } else if m == 4 {
        // XOR
        let d = max(min(d1, d2), -max(d1, d2));
        if d1 < d2 {
            return vec4<f32>(d, c1);
        }
        return vec4<f32>(d, c2);
    }
    
    // Default
    if d2 < d1 {
        return vec4<f32>(d2, c2);
    }
    return vec4<f32>(d1, c1);
}

// ===== SCENE EVALUATION =====
// Returns vec4(distance, color.rgb)
fn get_scene(p: vec3<f32>) -> vec4<f32> {
    // Start with ground plane
    let plane_dist = sd_plane(p, vec3<f32>(0.0, 1.0, 0.0), 0.5);
    let checker = floor(p.x) + floor(p.z);
    let plane_color = select(vec3<f32>(0.2, 0.2, 0.2), vec3<f32>(0.9, 0.9, 0.9), i32(checker) % 2 == 0);
    
    var result = vec4<f32>(plane_dist, plane_color);
    
    // Track the "dominant" smooth amount from any object in smooth mode
    // This allows smooth objects to affect normal objects nearby
    var active_smooth: f32 = 0.0;
    
    // Process spheres
    for (var i = 0u; i < scene.num_spheres && i < 10u; i++) {
        let sphere = scene.spheres[i];
        let d = sd_sphere(p - sphere.center, sphere.radius);
        
        // If this sphere is in smooth mode, update the active smooth value
        if sphere.blend_mode > 0.5 && sphere.blend_mode < 1.5 {
            active_smooth = max(active_smooth, sphere.blend_amount);
        }
        
        // Determine effective mode and smoothness
        var effective_mode = sphere.blend_mode;
        var effective_k = sphere.blend_amount;
        
        // If object is "Normal" but there's active smooth from another object, use smooth
        if sphere.blend_mode < 0.5 && active_smooth > 0.01 {
            effective_mode = 1.0;  // Switch to smooth union
            effective_k = active_smooth;
        }
        
        result = csg_blend(result.x, result.yzw, d, sphere.color, effective_mode, effective_k);
    }
    
    // Process boxes
    for (var i = 0u; i < scene.num_boxes && i < 10u; i++) {
        let box = scene.boxes[i];
        let d = sd_box(p - box.center, box.size);
        
        if box.blend_mode > 0.5 && box.blend_mode < 1.5 {
            active_smooth = max(active_smooth, box.blend_amount);
        }
        
        var effective_mode = box.blend_mode;
        var effective_k = box.blend_amount;
        
        if box.blend_mode < 0.5 && active_smooth > 0.01 {
            effective_mode = 1.0;
            effective_k = active_smooth;
        }
        
        result = csg_blend(result.x, result.yzw, d, box.color, effective_mode, effective_k);
    }
    
    // Process tori
    for (var i = 0u; i < scene.num_tori && i < 10u; i++) {
        let torus = scene.tori[i];
        let d = sd_torus(p - torus.center, torus.radii);
        
        if torus.blend_mode > 0.5 && torus.blend_mode < 1.5 {
            active_smooth = max(active_smooth, torus.blend_amount);
        }
        
        var effective_mode = torus.blend_mode;
        var effective_k = torus.blend_amount;
        
        if torus.blend_mode < 0.5 && active_smooth > 0.01 {
            effective_mode = 1.0;
            effective_k = active_smooth;
        }
        
        result = csg_blend(result.x, result.yzw, d, torus.color, effective_mode, effective_k);
    }
    
    return result;
}

// Simple distance query for normals
fn get_dist(p: vec3<f32>) -> f32 {
    return get_scene(p).x;
}

// ===== RAY MARCHING =====
struct HitResult {
    dist: f32,
    color: vec3<f32>,
    hit: bool,
}

fn ray_march(ro: vec3<f32>, rd: vec3<f32>) -> HitResult {
    var d = 0.0;
    var result: HitResult;
    result.hit = false;
    result.color = vec3<f32>(0.7, 0.8, 0.9); // Sky color
    
    for (var i = 0; i < MAX_STEPS; i++) {
        let p = ro + rd * d;
        let scene_result = get_scene(p);
        let step_dist = scene_result.x;
        
        if step_dist < SURF_DIST {
            result.dist = d;
            result.color = scene_result.yzw;
            result.hit = true;
            break;
        }
        
        d += step_dist;
        
        if d > MAX_DIST {
            break;
        }
    }
    
    result.dist = d;
    return result;
}

// ===== NORMALS =====
fn get_normal(p: vec3<f32>) -> vec3<f32> {
    let e = vec2<f32>(0.001, 0.0);
    let n = vec3<f32>(
        get_dist(p + e.xyy) - get_dist(p - e.xyy),
        get_dist(p + e.yxy) - get_dist(p - e.yxy),
        get_dist(p + e.yyx) - get_dist(p - e.yyx)
    );
    return normalize(n);
}

// ===== MAIN FRAGMENT SHADER =====
@fragment
fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
    let uv = (fragCoord.xy - uniforms.resolution * 0.5) / min(uniforms.resolution.x, uniforms.resolution.y);
    
    // Camera setup
    let yaw = uniforms.cameraYaw;
    let pitch = uniforms.cameraPitch;
    let cam_dist = uniforms.cameraDistance;
    
    let cam_target = vec3<f32>(
        uniforms.cameraTargetX,
        uniforms.cameraTargetY,
        uniforms.cameraTargetZ
    );
    
    let cam_pos = vec3<f32>(
        sin(yaw) * cos(pitch),
        sin(pitch),
        cos(yaw) * cos(pitch)
    ) * cam_dist + cam_target;
    
    // Camera matrix
    let cam_forward = normalize(cam_target - cam_pos);
    let cam_right = normalize(cross(cam_forward, vec3<f32>(0.0, 1.0, 0.0)));
    let cam_up = cross(cam_right, cam_forward);
    
    // Ray direction
    let focal_length = 1.5;
    let rd = normalize(cam_right * uv.x - cam_up * uv.y + cam_forward * focal_length);
    
    // Ray march
    let hit = ray_march(cam_pos, rd);
    
    if hit.hit {
        let hit_pos = cam_pos + rd * hit.dist;
        let normal = get_normal(hit_pos);
        
        // Lighting
        let light_pos = vec3<f32>(3.0, 5.0, -2.0);
        let light_dir = normalize(light_pos - hit_pos);
        let diffuse = max(dot(normal, light_dir), 0.0);
        
        // Shadow
        let shadow_origin = hit_pos + normal * 0.02;
        let shadow_hit = ray_march(shadow_origin, light_dir);
        let in_shadow = shadow_hit.hit && shadow_hit.dist < length(light_pos - shadow_origin);
        let shadow = select(1.0, 0.3, in_shadow);
        
        // Ambient + Diffuse
        let ambient = 0.15;
        let color = hit.color * (ambient + diffuse * shadow * 0.85);
        
        // Fog
        let fog = exp(-hit.dist * 0.03);
        let sky_color = vec3<f32>(0.7, 0.8, 0.9);
        let final_color = mix(sky_color, color, fog);
        
        return vec4<f32>(pow(final_color, vec3<f32>(1.0 / 2.2)), 1.0);
    }
    
    // Sky gradient
    let sky = mix(vec3<f32>(0.6, 0.7, 0.9), vec3<f32>(0.9, 0.95, 1.0), uv.y * 0.5 + 0.5);
    return vec4<f32>(pow(sky, vec3<f32>(1.0 / 2.2)), 1.0);
}
`;

        // ================================================
        // WEBGPU INITIALIZATION
        // ================================================
        
        async function initWebGPU() {
            canvas = document.getElementById('canvas');
            
            if (!navigator.gpu) {
                showError('WebGPU not supported in this browser. Use Chrome 113+ or Edge 113+');
                return false;
            }
            
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                showError('No GPU adapter found');
                return false;
            }
            
            device = await adapter.requestDevice();
            context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });
            
            uniformBuffer = device.createBuffer({
                size: 96,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                label: 'Uniform Buffer'
            });
            
            // Scene buffer layout:
            // Header: 4 u32 (16 bytes)
            // Spheres: 10 * 12 floats = 120 floats (480 bytes)
            // Boxes: 10 * 16 floats = 160 floats (640 bytes)
            // Tori: 10 * 16 floats = 160 floats (640 bytes)
            // Total: 4 + 440 = 444 floats = 1776 bytes
            
            const defaultColors = [
                [1.0, 0.3, 0.3], // Red
                [0.3, 0.5, 1.0], // Blue
                [1.0, 1.0, 0.3], // Yellow
                [0.7, 0.3, 1.0], // Purple
                [1.0, 0.5, 0.7], // Pink
                [0.3, 0.9, 0.9], // Cyan
                [0.2, 0.8, 0.5], // Teal
                [0.5, 0.3, 0.9], // Indigo
                [0.8, 0.4, 1.0], // Violet
                [1.0, 0.4, 0.5], // Rose
            ];
            
            sceneData = new Float32Array(444);
            
            // Initialize header to 0
            sceneData[0] = 0; // num_spheres
            sceneData[1] = 0; // num_boxes
            sceneData[2] = 0; // num_tori
            sceneData[3] = 0; // padding
            
            // Initialize spheres (12 floats each)
            for (let i = 0; i < 10; i++) {
                const offset = 4 + i * 12;
                sceneData[offset + 0] = i * 0.8 - 2.0;  // x
                sceneData[offset + 1] = 0.5;            // y
                sceneData[offset + 2] = 0.0;            // z
                sceneData[offset + 3] = 0.4;            // radius
                sceneData[offset + 4] = defaultColors[i][0]; // R
                sceneData[offset + 5] = defaultColors[i][1]; // G
                sceneData[offset + 6] = defaultColors[i][2]; // B
                sceneData[offset + 7] = 0.0;            // blend_mode (Normal)
                sceneData[offset + 8] = 0.3;            // blend_amount
            }
            
            // Initialize boxes (16 floats each)
            for (let i = 0; i < 10; i++) {
                const offset = 4 + 120 + i * 16;
                sceneData[offset + 0] = i * 0.8 - 2.0;  // x
                sceneData[offset + 1] = 0.3;            // y
                sceneData[offset + 2] = 1.5;            // z
                sceneData[offset + 3] = 0.0;            // padding
                sceneData[offset + 4] = 0.3;            // size x
                sceneData[offset + 5] = 0.3;            // size y
                sceneData[offset + 6] = 0.3;            // size z
                sceneData[offset + 7] = 0.0;            // padding
                const ci = (i + 3) % 10;
                sceneData[offset + 8] = defaultColors[ci][0];  // R
                sceneData[offset + 9] = defaultColors[ci][1];  // G
                sceneData[offset + 10] = defaultColors[ci][2]; // B
                sceneData[offset + 11] = 0.0;           // blend_mode
                sceneData[offset + 12] = 0.3;           // blend_amount
            }
            
            // Initialize tori (16 floats each)
            for (let i = 0; i < 10; i++) {
                const offset = 4 + 120 + 160 + i * 16;
                sceneData[offset + 0] = i * 0.8 - 2.0;  // x
                sceneData[offset + 1] = 0.5;            // y
                sceneData[offset + 2] = -1.5;           // z
                sceneData[offset + 3] = 0.0;            // padding
                sceneData[offset + 4] = 0.35;           // major radius
                sceneData[offset + 5] = 0.12;           // minor radius
                sceneData[offset + 6] = 0.0;            // padding
                sceneData[offset + 7] = 0.0;            // padding
                const ci = (i + 5) % 10;
                sceneData[offset + 8] = defaultColors[ci][0];  // R
                sceneData[offset + 9] = defaultColors[ci][1];  // G
                sceneData[offset + 10] = defaultColors[ci][2]; // B
                sceneData[offset + 11] = 0.0;           // blend_mode
                sceneData[offset + 12] = 0.3;           // blend_amount
            }
            
            sceneBuffer = device.createBuffer({
                size: sceneData.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                label: 'Scene Buffer'
            });
            
            // Write initial data
            const headerData = new Uint32Array([0, 0, 0, 0]);
            device.queue.writeBuffer(sceneBuffer, 0, headerData);
            device.queue.writeBuffer(sceneBuffer, 16, sceneData.subarray(4));
            
            await compileShader(mainShader);
            
            return true;
        }
        
        // ================================================
        // SHADER COMPILATION
        // ================================================
        
        async function compileShader(fragmentCode) {
            try {
                hideError();
                
                const code = vertexShader + '\n' + uniformsStruct + '\n' + sceneStruct + '\n' + fragmentCode;
                const shaderModule = device.createShaderModule({ code });
                
                const info = await shaderModule.getCompilationInfo();
                const errors = info.messages.filter(m => m.type === 'error');
                
                if (errors.length > 0) {
                    const errorText = errors.map(e => `Line ${e.lineNum}: ${e.message}`).join('\n');
                    showError('Shader compilation error:\n' + errorText);
                    return;
                }
                
                const format = navigator.gpu.getPreferredCanvasFormat();
                
                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                        { binding: 1, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } }
                    ]
                });
                
                pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                    vertex: { module: shaderModule, entryPoint: 'vs_main' },
                    fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format }] },
                    primitive: { topology: 'triangle-list' }
                });
                
                bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: uniformBuffer } },
                        { binding: 1, resource: { buffer: sceneBuffer } }
                    ]
                });
                
                console.log('‚úÖ Shader compiled successfully');
                
            } catch (e) {
                showError('Compilation error: ' + e.message);
                console.error(e);
            }
        }
        
        // ================================================
        // RENDER LOOP
        // ================================================
        
        function render() {
            if (!pipeline) {
                requestAnimationFrame(render);
                return;
            }
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            const elapsedTime = (currentTime - startTime) / 1000;
            
            const uniformData = new Float32Array([
                canvas.width, canvas.height,
                elapsedTime,
                deltaTime,
                mouseX, mouseY, mouseDown, 0,
                frameCount, 0, 0, 0,
                cameraYaw, cameraPitch, cameraDistance, 0,
                cameraTargetX, cameraTargetY, cameraTargetZ, 0
            ]);
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);
            
            document.getElementById('u-resolution').textContent = `${canvas.width}x${canvas.height}`;
            document.getElementById('u-time').textContent = elapsedTime.toFixed(2) + 's';
            document.getElementById('u-frame').textContent = frameCount;
            document.getElementById('u-mouse').textContent = `(${mouseX.toFixed(0)}, ${mouseY.toFixed(0)})`;
            
            const encoder = device.createCommandEncoder();
            const pass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    storeOp: 'store'
                }]
            });
            
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bindGroup);
            pass.draw(3);
            pass.end();
            
            device.queue.submit([encoder.finish()]);
            
            frameCount++;
            if (currentTime - lastFpsUpdate > 100) {
                const fps = Math.round(frameCount / ((currentTime - lastFpsUpdate) / 1000));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            lastFrameTime = currentTime;
            requestAnimationFrame(render);
        }
        
        // ================================================
        // DYNAMIC UI GENERATION
        // ================================================
        
        const sphereNames = ['üî¥ Red', 'üîµ Blue', 'üü° Yellow', 'üü£ Purple', 'ü©∑ Pink', 'üî∑ Cyan', 'üü¢ Teal', 'üîπ Indigo', 'üíú Violet', 'üåπ Rose'];
        const boxNames = ['üü© Green', 'üü™ Magenta', 'üü¶ Blue', 'üüß Orange', 'üü• Red', 'üíô Cyan', 'üíö Lime', 'üíõ Yellow', 'üß° Amber', 'üíú Purple'];
        const torusNames = ['üç© Cyan', 'üç© Orange', 'üç© Red', 'üç© Pink', 'üç© Yellow', 'üç© Green', 'üç© Blue', 'üç© Indigo', 'üç© Violet', 'üç© Rose'];
        
        function createObjectPanel(type, index) {
            const names = type === 'sphere' ? sphereNames : type === 'box' ? boxNames : torusNames;
            const colorClass = type === 'sphere' ? 'text-red-400' : type === 'box' ? 'text-green-400' : 'text-cyan-400';
            
            const panel = document.createElement('div');
            panel.id = `${type}-${index}-panel`;
            panel.className = 'space-y-3 mb-4 p-3 bg-gray-800 rounded-lg border border-gray-600';
            panel.style.display = 'none';
            
            let sizeControls = '';
            if (type === 'sphere') {
                sizeControls = `
                    <div>
                        <label class="text-xs flex justify-between mb-1">
                            <span class="text-gray-400">Radius</span>
                            <span id="${type}-${index}-radius-value" class="font-mono text-yellow-400">0.40</span>
                        </label>
                        <input type="range" id="${type}-${index}-radius" min="0.1" max="1.5" step="0.01" value="0.4" class="w-full">
                    </div>
                `;
            } else if (type === 'box') {
                sizeControls = `
                    <div>
                        <label class="text-xs flex justify-between mb-1">
                            <span class="text-gray-400">Size</span>
                            <span id="${type}-${index}-size-value" class="font-mono text-yellow-400">0.30</span>
                        </label>
                        <input type="range" id="${type}-${index}-size" min="0.1" max="1.0" step="0.01" value="0.3" class="w-full">
                    </div>
                `;
            } else {
                sizeControls = `
                    <div>
                        <label class="text-xs flex justify-between mb-1">
                            <span class="text-gray-400">Major R</span>
                            <span id="${type}-${index}-major-value" class="font-mono text-yellow-400">0.35</span>
                        </label>
                        <input type="range" id="${type}-${index}-major" min="0.1" max="0.8" step="0.01" value="0.35" class="w-full">
                    </div>
                    <div>
                        <label class="text-xs flex justify-between mb-1">
                            <span class="text-gray-400">Minor R</span>
                            <span id="${type}-${index}-minor-value" class="font-mono text-yellow-400">0.12</span>
                        </label>
                        <input type="range" id="${type}-${index}-minor" min="0.03" max="0.3" step="0.01" value="0.12" class="w-full">
                    </div>
                `;
            }
            
            panel.innerHTML = `
                <div class="text-sm font-semibold ${colorClass} mb-2">${names[index]} ${type.charAt(0).toUpperCase() + type.slice(1)} ${index + 1}</div>
                
                <div class="grid grid-cols-3 gap-2">
                    <div>
                        <label class="text-xs block mb-1 text-gray-500">X</label>
                        <input type="range" id="${type}-${index}-x" min="-4" max="4" step="0.05" value="0" class="w-full">
                        <div id="${type}-${index}-x-value" class="text-xs text-center font-mono text-yellow-400">0.00</div>
                    </div>
                    <div>
                        <label class="text-xs block mb-1 text-gray-500">Y</label>
                        <input type="range" id="${type}-${index}-y" min="-2" max="3" step="0.05" value="0.5" class="w-full">
                        <div id="${type}-${index}-y-value" class="text-xs text-center font-mono text-yellow-400">0.50</div>
                    </div>
                    <div>
                        <label class="text-xs block mb-1 text-gray-500">Z</label>
                        <input type="range" id="${type}-${index}-z" min="-4" max="4" step="0.05" value="0" class="w-full">
                        <div id="${type}-${index}-z-value" class="text-xs text-center font-mono text-yellow-400">0.00</div>
                    </div>
                </div>
                
                ${sizeControls}
                
                <div>
                    <label class="text-xs block mb-1 text-gray-400">Color</label>
                    <input type="color" id="${type}-${index}-color" value="#ff4d4d" class="w-full h-8 rounded cursor-pointer border border-gray-600">
                </div>
                
                <div class="csg-controls">
                    <div class="text-xs font-semibold text-purple-400 mb-2">‚öôÔ∏è CSG Mode</div>
                    <select id="${type}-${index}-blend-mode" class="w-full bg-gray-700 text-white rounded px-2 py-1 text-xs mb-2">
                        <option value="0">Normal (auto-smooth)</option>
                        <option value="1">Smooth Union ‚≠ê</option>
                        <option value="2">Subtract (creuse)</option>
                        <option value="3">Intersect (overlap)</option>
                        <option value="4">XOR (exclusion)</option>
                    </select>
                    <div>
                        <label class="text-xs flex justify-between mb-1">
                            <span class="text-gray-400">Smoothness</span>
                            <span id="${type}-${index}-blend-amount-value" class="font-mono text-purple-400">0.30</span>
                        </label>
                        <input type="range" id="${type}-${index}-blend-amount" min="0.05" max="1.0" step="0.05" value="0.3" class="w-full">
                    </div>
                </div>
            `;
            
            return panel;
        }
        
        function setupObjectUpdater(type, index) {
            let baseOffset;
            if (type === 'sphere') {
                baseOffset = 4 + index * 12;
            } else if (type === 'box') {
                baseOffset = 4 + 120 + index * 16;
            } else {
                baseOffset = 4 + 120 + 160 + index * 16;
            }
            
            const controls = {
                x: document.getElementById(`${type}-${index}-x`),
                y: document.getElementById(`${type}-${index}-y`),
                z: document.getElementById(`${type}-${index}-z`),
                color: document.getElementById(`${type}-${index}-color`),
                blendMode: document.getElementById(`${type}-${index}-blend-mode`),
                blendAmount: document.getElementById(`${type}-${index}-blend-amount`)
            };
            
            if (type === 'sphere') {
                controls.radius = document.getElementById(`${type}-${index}-radius`);
            } else if (type === 'box') {
                controls.size = document.getElementById(`${type}-${index}-size`);
            } else {
                controls.major = document.getElementById(`${type}-${index}-major`);
                controls.minor = document.getElementById(`${type}-${index}-minor`);
            }
            
            // Initialize from sceneData
            controls.x.value = sceneData[baseOffset + 0];
            controls.y.value = sceneData[baseOffset + 1];
            controls.z.value = sceneData[baseOffset + 2];
            
            if (type === 'sphere') {
                controls.radius.value = sceneData[baseOffset + 3];
            } else if (type === 'box') {
                controls.size.value = sceneData[baseOffset + 4];
            } else {
                controls.major.value = sceneData[baseOffset + 4];
                controls.minor.value = sceneData[baseOffset + 5];
            }
            
            // Color
            const colorOffset = type === 'sphere' ? 4 : 8;
            const r = Math.round(sceneData[baseOffset + colorOffset] * 255);
            const g = Math.round(sceneData[baseOffset + colorOffset + 1] * 255);
            const b = Math.round(sceneData[baseOffset + colorOffset + 2] * 255);
            controls.color.value = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
            
            // CSG
            const blendOffset = type === 'sphere' ? 7 : 11;
            controls.blendMode.value = Math.round(sceneData[baseOffset + blendOffset]);
            controls.blendAmount.value = sceneData[baseOffset + blendOffset + 1];
            
            function update() {
                // Position
                sceneData[baseOffset + 0] = parseFloat(controls.x.value);
                sceneData[baseOffset + 1] = parseFloat(controls.y.value);
                sceneData[baseOffset + 2] = parseFloat(controls.z.value);
                
                // Update displays
                document.getElementById(`${type}-${index}-x-value`).textContent = parseFloat(controls.x.value).toFixed(2);
                document.getElementById(`${type}-${index}-y-value`).textContent = parseFloat(controls.y.value).toFixed(2);
                document.getElementById(`${type}-${index}-z-value`).textContent = parseFloat(controls.z.value).toFixed(2);
                
                if (type === 'sphere') {
                    sceneData[baseOffset + 3] = parseFloat(controls.radius.value);
                    document.getElementById(`${type}-${index}-radius-value`).textContent = parseFloat(controls.radius.value).toFixed(2);
                } else if (type === 'box') {
                    const size = parseFloat(controls.size.value);
                    sceneData[baseOffset + 4] = size;
                    sceneData[baseOffset + 5] = size;
                    sceneData[baseOffset + 6] = size;
                    document.getElementById(`${type}-${index}-size-value`).textContent = size.toFixed(2);
                } else {
                    sceneData[baseOffset + 4] = parseFloat(controls.major.value);
                    sceneData[baseOffset + 5] = parseFloat(controls.minor.value);
                    document.getElementById(`${type}-${index}-major-value`).textContent = parseFloat(controls.major.value).toFixed(2);
                    document.getElementById(`${type}-${index}-minor-value`).textContent = parseFloat(controls.minor.value).toFixed(2);
                }
                
                // Color
                const hex = controls.color.value;
                sceneData[baseOffset + colorOffset] = parseInt(hex.slice(1, 3), 16) / 255.0;
                sceneData[baseOffset + colorOffset + 1] = parseInt(hex.slice(3, 5), 16) / 255.0;
                sceneData[baseOffset + colorOffset + 2] = parseInt(hex.slice(5, 7), 16) / 255.0;
                
                // CSG
                sceneData[baseOffset + blendOffset] = parseFloat(controls.blendMode.value);
                sceneData[baseOffset + blendOffset + 1] = parseFloat(controls.blendAmount.value);
                document.getElementById(`${type}-${index}-blend-amount-value`).textContent = parseFloat(controls.blendAmount.value).toFixed(2);
                
                // Write to GPU
                if (device && sceneBuffer) {
                    const floatCount = type === 'sphere' ? 12 : 16;
                    device.queue.writeBuffer(sceneBuffer, baseOffset * 4, sceneData.subarray(baseOffset, baseOffset + floatCount));
                }
            }
            
            // Add listeners
            controls.x.addEventListener('input', update);
            controls.y.addEventListener('input', update);
            controls.z.addEventListener('input', update);
            controls.color.addEventListener('input', update);
            controls.blendMode.addEventListener('change', update);
            controls.blendAmount.addEventListener('input', update);
            
            if (controls.radius) controls.radius.addEventListener('input', update);
            if (controls.size) controls.size.addEventListener('input', update);
            if (controls.major) controls.major.addEventListener('input', update);
            if (controls.minor) controls.minor.addEventListener('input', update);
            
            // Initial update
            update();
        }
        
        function setupSceneEditor() {
            const container = document.getElementById('object-panels-container');
            
            // Create all panels
            for (let i = 0; i < 10; i++) {
                container.appendChild(createObjectPanel('sphere', i));
                container.appendChild(createObjectPanel('box', i));
                container.appendChild(createObjectPanel('torus', i));
            }
            
            // Setup updaters
            for (let i = 0; i < 10; i++) {
                setupObjectUpdater('sphere', i);
                setupObjectUpdater('box', i);
                setupObjectUpdater('torus', i);
            }
            
            function updateCounts() {
                // Update header
                const headerData = new Uint32Array([activeSpheres, activeBoxes, activeTori, 0]);
                device.queue.writeBuffer(sceneBuffer, 0, headerData);
                
                // Update UI
                document.getElementById('sphere-count').textContent = activeSpheres;
                document.getElementById('box-count').textContent = activeBoxes;
                document.getElementById('torus-count').textContent = activeTori;
                
                // Show/hide panels
                for (let i = 0; i < 10; i++) {
                    document.getElementById(`sphere-${i}-panel`).style.display = i < activeSpheres ? 'block' : 'none';
                    document.getElementById(`box-${i}-panel`).style.display = i < activeBoxes ? 'block' : 'none';
                    document.getElementById(`torus-${i}-panel`).style.display = i < activeTori ? 'block' : 'none';
                }
            }
            
            // Add/Remove buttons
            document.getElementById('add-sphere-btn').addEventListener('click', () => {
                if (activeSpheres < 10) {
                    activeSpheres++;
                    updateCounts();
                }
            });
            
            document.getElementById('remove-sphere-btn').addEventListener('click', () => {
                if (activeSpheres > 0) {
                    activeSpheres--;
                    updateCounts();
                }
            });
            
            document.getElementById('add-box-btn').addEventListener('click', () => {
                if (activeBoxes < 10) {
                    activeBoxes++;
                    updateCounts();
                }
            });
            
            document.getElementById('remove-box-btn').addEventListener('click', () => {
                if (activeBoxes > 0) {
                    activeBoxes--;
                    updateCounts();
                }
            });
            
            document.getElementById('add-torus-btn').addEventListener('click', () => {
                if (activeTori < 10) {
                    activeTori++;
                    updateCounts();
                }
            });
            
            document.getElementById('remove-torus-btn').addEventListener('click', () => {
                if (activeTori > 0) {
                    activeTori--;
                    updateCounts();
                }
            });
            
            // Initialize with 0 objects
            updateCounts();
        }
        
        // ================================================
        // UTILITY FUNCTIONS
        // ================================================
        
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }
        
        function hideError() {
            document.getElementById('error-message').classList.add('hidden');
        }
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            let width = window.innerWidth * dpr;
            let height = window.innerHeight * dpr;
            
            if (width > 8192) width = 8192;
            if (height > 8192) height = 8192;
            
            canvas.width = width;
            canvas.height = height;
        }
        
        // ================================================
        // CODEMIRROR SETUP
        // ================================================
        
        CodeMirror.defineSimpleMode("wgsl", {
            start: [
                {regex: /\/\/.*/, token: "comment"},
                {regex: /fn|struct|let|var|if|else|for|return|const/, token: "keyword"},
                {regex: /vec[234]|mat[234]x[234]|f32|i32|u32|bool/, token: "type"},
                {regex: /\d+\.\d+|\d+/, token: "number"},
                {regex: /"(?:[^\\]|\\.)*?"/, token: "string"},
                {regex: /[a-zA-Z_]\w*/, token: "variable"}
            ]
        });
        
        // ================================================
        // INITIALIZATION
        // ================================================
        
        (async () => {
            if (!(await initWebGPU())) return;
            
            const textarea = document.getElementById('code-editor');
            editor = CodeMirror.fromTextArea(textarea, {
                mode: 'wgsl',
                theme: 'gruvbox-dark',
                lineNumbers: true,
                lineWrapping: true,
                indentUnit: 2,
                tabSize: 2
            });
            
            editor.setValue(mainShader);
            
            setupSceneEditor();
            
            // Panel toggle
            const togglePanelBtn = document.getElementById('toggle-panel-btn');
            const floatingToggleBtn = document.getElementById('floating-toggle-btn');
            const editorSide = document.getElementById('editor-side');
            let panelVisible = true;
            
            function togglePanel() {
                panelVisible = !panelVisible;
                if (panelVisible) {
                    editorSide.classList.remove('panel-hidden');
                    togglePanelBtn.textContent = '‚úñÔ∏è Close';
                    floatingToggleBtn.classList.add('hidden');
                } else {
                    editorSide.classList.add('panel-hidden');
                    togglePanelBtn.textContent = 'üé® Show';
                    floatingToggleBtn.classList.remove('hidden');
                }
                setTimeout(resizeCanvas, 350);
            }
            
            togglePanelBtn.addEventListener('click', togglePanel);
            floatingToggleBtn.addEventListener('click', togglePanel);
            
            // Mouse events for camera AND object picking
            let clickStartX = 0, clickStartY = 0;
            
            // Project 3D point to screen coordinates
            function projectToScreen(worldPos) {
                const yaw = cameraYaw;
                const pitch = cameraPitch;
                const camDist = cameraDistance;
                
                const camPos = {
                    x: Math.sin(yaw) * Math.cos(pitch) * camDist + cameraTargetX,
                    y: Math.sin(pitch) * camDist + cameraTargetY,
                    z: Math.cos(yaw) * Math.cos(pitch) * camDist + cameraTargetZ
                };
                
                const camTarget = { x: cameraTargetX, y: cameraTargetY, z: cameraTargetZ };
                
                // Camera vectors
                const forward = normalize(sub(camTarget, camPos));
                const right = normalize(cross(forward, { x: 0, y: 1, z: 0 }));
                const up = cross(right, forward);
                
                // Vector from camera to point
                const toPoint = sub(worldPos, camPos);
                
                // Project onto camera plane
                const focalLength = 1.5;
                const depth = dot(toPoint, forward);
                
                if (depth <= 0.1) return null; // Behind camera
                
                const projX = dot(toPoint, right) / depth * focalLength;
                const projY = -dot(toPoint, up) / depth * focalLength;
                
                // Convert to screen coordinates
                const minDim = Math.min(canvas.width, canvas.height);
                const screenX = canvas.width / 2 + projX * minDim;
                const screenY = canvas.height / 2 + projY * minDim;
                
                return { x: screenX, y: screenY, depth: depth };
            }
            
            // Find closest object to screen position
            function pickObjectAt(screenX, screenY) {
                let bestObj = null;
                let bestDist = 80; // Max pixel distance to select (increased for easier picking)
                let bestDepth = Infinity;
                
                // Check all spheres
                for (let i = 0; i < activeSpheres; i++) {
                    const offset = 4 + i * 12;
                    const pos = { x: sceneData[offset], y: sceneData[offset + 1], z: sceneData[offset + 2] };
                    const radius = sceneData[offset + 3];
                    const proj = projectToScreen(pos);
                    
                    if (proj) {
                        const dx = proj.x - screenX;
                        const dy = proj.y - screenY;
                        const screenDist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Account for object size in screen space
                        const screenRadius = radius * 150 / proj.depth;
                        const effectiveDist = Math.max(0, screenDist - screenRadius);
                        
                        if (effectiveDist < bestDist || (effectiveDist < bestDist + 20 && proj.depth < bestDepth)) {
                            bestDist = effectiveDist;
                            bestDepth = proj.depth;
                            bestObj = { type: 'sphere', index: i };
                        }
                    }
                }
                
                // Check all boxes
                for (let i = 0; i < activeBoxes; i++) {
                    const offset = 4 + 120 + i * 16;
                    const pos = { x: sceneData[offset], y: sceneData[offset + 1], z: sceneData[offset + 2] };
                    const size = sceneData[offset + 4];
                    const proj = projectToScreen(pos);
                    
                    if (proj) {
                        const dx = proj.x - screenX;
                        const dy = proj.y - screenY;
                        const screenDist = Math.sqrt(dx * dx + dy * dy);
                        
                        const screenSize = size * 150 / proj.depth;
                        const effectiveDist = Math.max(0, screenDist - screenSize);
                        
                        if (effectiveDist < bestDist || (effectiveDist < bestDist + 20 && proj.depth < bestDepth)) {
                            bestDist = effectiveDist;
                            bestDepth = proj.depth;
                            bestObj = { type: 'box', index: i };
                        }
                    }
                }
                
                // Check all tori
                for (let i = 0; i < activeTori; i++) {
                    const offset = 4 + 120 + 160 + i * 16;
                    const pos = { x: sceneData[offset], y: sceneData[offset + 1], z: sceneData[offset + 2] };
                    const majorR = sceneData[offset + 4];
                    const proj = projectToScreen(pos);
                    
                    if (proj) {
                        const dx = proj.x - screenX;
                        const dy = proj.y - screenY;
                        const screenDist = Math.sqrt(dx * dx + dy * dy);
                        
                        const screenSize = majorR * 150 / proj.depth;
                        const effectiveDist = Math.max(0, screenDist - screenSize);
                        
                        if (effectiveDist < bestDist || (effectiveDist < bestDist + 20 && proj.depth < bestDepth)) {
                            bestDist = effectiveDist;
                            bestDepth = proj.depth;
                            bestObj = { type: 'torus', index: i };
                        }
                    }
                }
                
                console.log('Pick result:', bestObj, 'dist:', bestDist.toFixed(1));
                return bestObj;
            }
            
            // Vector math helpers
            function sub(a, b) { return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }; }
            function add(a, b) { return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }; }
            function scale(v, s) { return { x: v.x * s, y: v.y * s, z: v.z * s }; }
            function length(v) { return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z); }
            function normalize(v) { const l = length(v) || 1; return { x: v.x / l, y: v.y / l, z: v.z / l }; }
            function cross(a, b) { return { x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x }; }
            function dot(a, b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
            
            // Get object position
            function getObjectPosition(obj) {
                let offset;
                if (obj.type === 'sphere') offset = 4 + obj.index * 12;
                else if (obj.type === 'box') offset = 4 + 120 + obj.index * 16;
                else offset = 4 + 120 + 160 + obj.index * 16;
                return { x: sceneData[offset], y: sceneData[offset + 1], z: sceneData[offset + 2] };
            }
            
            // Set object position and update UI
            function setObjectPosition(obj, pos) {
                let offset;
                if (obj.type === 'sphere') offset = 4 + obj.index * 12;
                else if (obj.type === 'box') offset = 4 + 120 + obj.index * 16;
                else offset = 4 + 120 + 160 + obj.index * 16;
                
                // Clamp position
                pos.x = Math.max(-4, Math.min(4, pos.x));
                pos.y = Math.max(-2, Math.min(3, pos.y));
                pos.z = Math.max(-4, Math.min(4, pos.z));
                
                sceneData[offset] = pos.x;
                sceneData[offset + 1] = pos.y;
                sceneData[offset + 2] = pos.z;
                
                // Update sliders
                const xSlider = document.getElementById(`${obj.type}-${obj.index}-x`);
                const ySlider = document.getElementById(`${obj.type}-${obj.index}-y`);
                const zSlider = document.getElementById(`${obj.type}-${obj.index}-z`);
                if (xSlider) xSlider.value = pos.x;
                if (ySlider) ySlider.value = pos.y;
                if (zSlider) zSlider.value = pos.z;
                
                // Update displays
                const xVal = document.getElementById(`${obj.type}-${obj.index}-x-value`);
                const yVal = document.getElementById(`${obj.type}-${obj.index}-y-value`);
                const zVal = document.getElementById(`${obj.type}-${obj.index}-z-value`);
                if (xVal) xVal.textContent = pos.x.toFixed(2);
                if (yVal) yVal.textContent = pos.y.toFixed(2);
                if (zVal) zVal.textContent = pos.z.toFixed(2);
                
                // Write to GPU
                const floatCount = obj.type === 'sphere' ? 12 : 16;
                device.queue.writeBuffer(sceneBuffer, offset * 4, sceneData.subarray(offset, offset + floatCount));
            }
            
            // Highlight selected panel
            function highlightPanel(obj) {
                // Remove previous highlights
                document.querySelectorAll('[id$="-panel"]').forEach(p => {
                    p.style.boxShadow = '';
                    p.style.borderColor = '';
                });
                
                if (obj) {
                    const panel = document.getElementById(`${obj.type}-${obj.index}-panel`);
                    if (panel) {
                        panel.style.boxShadow = '0 0 15px rgba(251, 191, 36, 0.6)';
                        panel.style.borderColor = '#fbbf24';
                        panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                clickStartX = e.clientX;
                clickStartY = e.clientY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Try to pick an object
                const obj = pickObjectAt(x, y);
                
                if (obj) {
                    selectedObject = obj;
                    isDraggingObject = true;
                    canvas.style.cursor = 'move';
                    highlightPanel(obj);
                } else {
                    selectedObject = null;
                    isDraggingObject = false;
                    isDragging = true;
                    mouseDown = 1;
                    canvas.style.cursor = 'grabbing';
                    highlightPanel(null);
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                if (isDraggingObject && selectedObject) {
                    // Move object in world space
                    const yaw = cameraYaw;
                    
                    // Camera right vector (in XZ plane)
                    const rightX = Math.cos(yaw);
                    const rightZ = -Math.sin(yaw);
                    
                    // Movement speed based on camera distance
                    const speed = 0.004 * cameraDistance;
                    
                    const currentPos = getObjectPosition(selectedObject);
                    const newPos = {
                        x: currentPos.x + rightX * deltaX * speed,
                        y: currentPos.y - deltaY * speed,
                        z: currentPos.z + rightZ * deltaX * speed
                    };
                    
                    setObjectPosition(selectedObject, newPos);
                    
                } else if (isDragging) {
                    // Camera rotation/pan
                    if (e.shiftKey) {
                        const panSpeed = 0.005;
                        cameraTargetX -= deltaX * panSpeed * cameraDistance;
                        cameraTargetY += deltaY * panSpeed * cameraDistance;
                    } else {
                        const rotateSpeed = 0.005;
                        cameraYaw -= deltaX * rotateSpeed;
                        cameraPitch += deltaY * rotateSpeed;
                        cameraPitch = Math.max(0.05, Math.min(1.5, cameraPitch));
                    }
                }
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                isDraggingObject = false;
                mouseDown = 0;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                isDraggingObject = false;
                mouseDown = 0;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.001;
                cameraDistance += e.deltaY * zoomSpeed * cameraDistance;
                cameraDistance = Math.max(1.0, Math.min(20.0, cameraDistance));
            }, { passive: false });
            
            canvas.style.cursor = 'grab';
            
            // Compile button
            document.getElementById('compile-btn').addEventListener('click', () => {
                compileShader(editor.getValue());
            });
            
            // Keyboard shortcuts
            editor.setOption('extraKeys', {
                'Ctrl-Enter': () => compileShader(editor.getValue()),
                'Cmd-Enter': () => compileShader(editor.getValue())
            });
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            render();
            
            console.log('‚úÖ WebGPU Scene Editor with CSG initialized');
        })();
    </script>
</body>
</html>